{"type":"issue","id":"absynthe-b31s328k","rev":"01KCWJ7Y538PKM1XJQQFYRA5V0","title":"Dataflow field traversal crashes on improper lists (rand state)","body":"Found via stress test: `find_and_reassign_fields/2` in lib/absynthe/dataflow/field.ex:284-286 crashes when an entity contains a `:rand.state()` tuple, which internally stores an improper list like `[int | int]`.\n\nStack trace:\n```\n** (FunctionClauseError) no function clause matching in Enum.\"-each/2-lists^foreach/1-0-\"/2\n    lib/enum.ex:961: Enum.\"-each/2-lists^foreach/1-0-\"(#Function<...>, 124801846992028383)\n    lib/absynthe/dataflow/field.ex:262: Absynthe.Dataflow.Field.reassign_all_owners/2\n    lib/absynthe/core/actor.ex:1079: Absynthe.Core.Actor.spawn_entity_impl/3\n```\n\nThe code at line 284 does `Enum.each(list, ...)` but doesn't check if the list is proper. When traversing a Trader entity with `rand_state`, it hits the improper list and crashes.\n\nFix options:\n1. Guard against improper lists with a helper like `proper_list?/1`\n2. Use try/rescue around list traversal\n3. Add a catch-all pattern that handles traversal failures gracefully","status":"open","priority":1,"tags":["bug"],"created_at":1766190217379,"updated_at":1766190217379}
{"type":"issue","id":"absynthe-b31s328k","rev":"01KCWJ7Y5A42T3HVPMKF0XJDEP","title":"Dataflow field traversal crashes on improper lists (rand state)","body":"Found via stress test: `find_and_reassign_fields/2` in lib/absynthe/dataflow/field.ex:284-286 crashes when an entity contains a `:rand.state()` tuple, which internally stores an improper list like `[int | int]`.\n\nStack trace:\n```\n** (FunctionClauseError) no function clause matching in Enum.\"-each/2-lists^foreach/1-0-\"/2\n    lib/enum.ex:961: Enum.\"-each/2-lists^foreach/1-0-\"(#Function<...>, 124801846992028383)\n    lib/absynthe/dataflow/field.ex:262: Absynthe.Dataflow.Field.reassign_all_owners/2\n    lib/absynthe/core/actor.ex:1079: Absynthe.Core.Actor.spawn_entity_impl/3\n```\n\nThe code at line 284 does `Enum.each(list, ...)` but doesn't check if the list is proper. When traversing a Trader entity with `rand_state`, it hits the improper list and crashes.\n\nFix options:\n1. Guard against improper lists with a helper like `proper_list?/1`\n2. Use try/rescue around list traversal\n3. Add a catch-all pattern that handles traversal failures gracefully","status":"closed","priority":1,"tags":["bug"],"created_at":1766190217379,"updated_at":1766190217386}
{"type":"issue","id":"absynthe-aih56cx6","rev":"01KCWJ7Y5HR1ZDTWZ8RJQJ86GS","title":"Epic: Relay-driven market stress example to flush SAM bugs","body":"End-to-end stress test using a simulated market to exercise relay, gatekeeper, dataspaces, flow control, and telemetry under high churn.","status":"open","priority":2,"tags":["epic"],"created_at":1766190217393,"updated_at":1766190217393}
{"type":"issue","id":"absynthe-3mv0fa9z","rev":"01KCWJ7Y5QFSVKFRQ1SNE0DPJH","title":"Spec load scenario + acceptance for stress example","body":"Document load profile, acceptance criteria, and expected metrics. DONE - documented in examples/stress/README.md","status":"open","priority":2,"tags":["task"],"created_at":1766190217399,"updated_at":1766190217399}
{"type":"issue","id":"absynthe-3mv0fa9z","rev":"01KCWJ7Y5YTC8PQXNFP91P3MHZ","title":"Spec load scenario + acceptance for stress example","body":"Document load profile, acceptance criteria, and expected metrics. DONE - documented in examples/stress/README.md","status":"closed","priority":2,"tags":["task"],"created_at":1766190217399,"updated_at":1766190217406}
{"type":"issue","id":"absynthe-bdj1bxrb","rev":"01KCWJ7Y64EKRDKW010VXGS3A8","title":"Relay + gatekeeper ingress with attenuated sturdy refs","body":"Wire up relay listener with gatekeeper for authenticated market access.","status":"open","priority":2,"tags":["task"],"created_at":1766190217412,"updated_at":1766190217412}
{"type":"issue","id":"absynthe-7nlpoxj0","rev":"01KCWJ7Y6AWDS75N2QV9C4ZEKG","title":"Dataspace matcher/history + reactive analytics entities","body":"Market entities: OrderBook, Matcher, History, Analytics. DONE - implemented in commit 69bb4db","status":"open","priority":2,"tags":["task"],"created_at":1766190217418,"updated_at":1766190217418}
{"type":"issue","id":"absynthe-7nlpoxj0","rev":"01KCWJ7Y6H2KPPRZZF6BQ5R8X3","title":"Dataspace matcher/history + reactive analytics entities","body":"Market entities: OrderBook, Matcher, History, Analytics. DONE - implemented in commit 69bb4db","status":"closed","priority":2,"tags":["task"],"created_at":1766190217418,"updated_at":1766190217425}
{"type":"issue","id":"absynthe-30a7tqhd","rev":"01KCWJ7Y6R39WCM4ZZG1A32EZ8","title":"Flow-control + telemetry validation under churn","body":"Verify flow control and telemetry hold up under market load.","status":"open","priority":2,"tags":["task"],"created_at":1766190217432,"updated_at":1766190217432}
{"type":"issue","id":"absynthe-d2bk6ix9","rev":"01KCWJ7Y6ZWWA92G8HW6XQW6HT","title":"Load harness: multi-client generator + chaos","body":"Build multi-trader generator with chaos injection for stress testing.","status":"open","priority":2,"tags":["task"],"created_at":1766190217439,"updated_at":1766190217439}
{"type":"issue","id":"absynthe-d2bk6ix9","rev":"01KCWJ7Y76TRCCSNFT2188KNNJ","title":"Load harness: multi-client generator + chaos","body":"Build multi-trader generator with chaos injection for stress testing.","status":"closed","priority":2,"tags":["task"],"created_at":1766190217439,"updated_at":1766190217446}
{"type":"issue","id":"absynthe-33se7el0","rev":"01KCWJ7Y7CHP3H5MQMMCQ0J8FB","title":"Bug triage + regression tracking from stress run","body":"Track and triage bugs found during stress testing.","status":"open","priority":2,"tags":["task"],"created_at":1766190217452,"updated_at":1766190217452}
{"type":"issue","id":"absynthe-7fhh30hr","rev":"01KCWJ7Y7J4AYP0KVVEY8EQ5FX","title":"Performance: address scalability bottlenecks from review","body":"Parent epic for performance optimizations identified in docs/performance_review.md and validated against syndicate-rs implementation patterns.\n\n## Children\n- [deleted:absynthe-9c5]: Skeleton observer indexing (O(n²) -> O(matching))\n- [deleted:absynthe-391]: Async local delivery (deep stacks -> shallow queues)\n- [deleted:absynthe-j8f]: Per-turn flow control (internal cascades)\n- [deleted:absynthe-pex]: MapSet-in-ETS replacement (GC pressure)\n- absynthe-0cd: Assertion payload deduplication (memory)\n- [deleted:absynthe-1vw]: Debt timeout removal (overload prevention)\n\n## Priority order (suggested)\n1. Observer indexing ([deleted:absynthe-9c5]) - highest impact for observer-heavy workloads\n2. Debt timeout fix ([deleted:absynthe-1vw]) - correctness issue, quick fix\n3. Async local delivery ([deleted:absynthe-391]) - stack safety, enables flow control\n4. Per-turn flow control ([deleted:absynthe-j8f]) - requires async delivery first\n5. MapSet replacement ([deleted:absynthe-pex]) - GC optimization\n6. Assertion deduplication (absynthe-0cd) - memory optimization","status":"open","priority":2,"tags":["feature"],"created_at":1766190217458,"updated_at":1766190217458}
{"type":"issue","id":"absynthe-3y3ikipm","rev":"01KCWJ7Y7S2M9TSNHQ463NPWY1","title":"Implement Syndicate network protocol/broker","body":"`syndicate-rs` ships a full distributed broker (`syndicate-server/src/main.rs`) with TCP/Unix relay listeners, gatekeeper, resolution client, HTTP router, and config watcher services. The core protocol/relay implementation lives in `syndicate/src/relay.rs` and moves caps/handles across the wire. Absynthe is intentionally single-node today (README, `Absynthe.Core.Actor` docs) with no transport or remote dataspace support. We need a server/broker that speaks the Syndicate protocol, can accept TCP/Unix connections, and tunnels dataspace traffic (assert/retract/message/sync) across nodes with the membrane/handle mapping that the Rust relay uses. Include gatekeeper/sturdy-ref resolution so remote clients can be authorized, and cover the basics with a cross-node ping-pong or presence example + tests.","status":"open","priority":2,"tags":["feature"],"created_at":1766190217465,"updated_at":1766190217465}
{"type":"issue","id":"absynthe-3y3ikipm","rev":"01KCWJ7Y7ZCPQXP2NKN0VPD19F","title":"Implement Syndicate network protocol/broker","body":"`syndicate-rs` ships a full distributed broker (`syndicate-server/src/main.rs`) with TCP/Unix relay listeners, gatekeeper, resolution client, HTTP router, and config watcher services. The core protocol/relay implementation lives in `syndicate/src/relay.rs` and moves caps/handles across the wire. Absynthe is intentionally single-node today (README, `Absynthe.Core.Actor` docs) with no transport or remote dataspace support. We need a server/broker that speaks the Syndicate protocol, can accept TCP/Unix connections, and tunnels dataspace traffic (assert/retract/message/sync) across nodes with the membrane/handle mapping that the Rust relay uses. Include gatekeeper/sturdy-ref resolution so remote clients can be authorized, and cover the basics with a cross-node ping-pong or presence example + tests.","status":"closed","priority":2,"tags":["feature"],"created_at":1766190217465,"updated_at":1766190217471}
{"type":"issue","id":"absynthe-02knegxf","rev":"01KCWJ7Y869GDKD8XEGV97G30G","title":"Facet teardown does not retract assertions/Observe handles","body":"Facet lifetimes are not wired to assertion lifetimes: `terminate_facet_impl/2` only deletes entities and children (lib/absynthe/core/actor.ex:652-687) and the actor `terminate/2` callback just cleans dataflow fields (lib/absynthe/core/actor.ex:876-884), leaving any outbound assertions or Observe subscriptions in the dataspace. Turn-initiated asserts are not tracked either—`process_action/2` explicitly avoids recording them (lib/absynthe/core/actor.ex:781-786) and `assert_value/3` generates a handle that is never returned or stored (lib/absynthe.ex:411-415)—so there is no way to retract them when a facet dies. In syndicate-rs each facet owns its assertions and retracts them automatically on drop, ensuring fate-sharing; here stale assertions/subscriptions will persist after facet/actor termination.","status":"open","priority":2,"tags":["bug"],"created_at":1766190217478,"updated_at":1766190217478}
{"type":"issue","id":"absynthe-02knegxf","rev":"01KCWJ7Y8EBFZB8DG868CX7MMH","title":"Facet teardown does not retract assertions/Observe handles","body":"Facet lifetimes are not wired to assertion lifetimes: `terminate_facet_impl/2` only deletes entities and children (lib/absynthe/core/actor.ex:652-687) and the actor `terminate/2` callback just cleans dataflow fields (lib/absynthe/core/actor.ex:876-884), leaving any outbound assertions or Observe subscriptions in the dataspace. Turn-initiated asserts are not tracked either—`process_action/2` explicitly avoids recording them (lib/absynthe/core/actor.ex:781-786) and `assert_value/3` generates a handle that is never returned or stored (lib/absynthe.ex:411-415)—so there is no way to retract them when a facet dies. In syndicate-rs each facet owns its assertions and retracts them automatically on drop, ensuring fate-sharing; here stale assertions/subscriptions will persist after facet/actor termination.","status":"closed","priority":2,"tags":["bug"],"created_at":1766190217478,"updated_at":1766190217486}
{"type":"issue","id":"absynthe-6cvz5ciz","rev":"01KCWJ7Y8M6GZCZ1VHC1F8YJW1","title":"Observer notifications drop capture bindings","body":"Skeleton matching returns capture lists, but the dataspace ignores them when sending notifications: both `notify_observer_of_existing/3` and `notify_observers_of_publish/4` throw away `_captures` and emit bare `Event.assert` calls (lib/absynthe/dataspace/dataspace.ex:410-424). That means even if patterns contain `$` captures, observers never learn the bound values. In syndicate-rs the observed assertion carries its match environment, so consumers can read captures; parity requires threading the bindings through to observers.","status":"open","priority":2,"tags":["bug"],"created_at":1766190217492,"updated_at":1766190217492}
{"type":"issue","id":"absynthe-6cvz5ciz","rev":"01KCWJ7Y8V04PVJXPJD9J33BPP","title":"Observer notifications drop capture bindings","body":"Skeleton matching returns capture lists, but the dataspace ignores them when sending notifications: both `notify_observer_of_existing/3` and `notify_observers_of_publish/4` throw away `_captures` and emit bare `Event.assert` calls (lib/absynthe/dataspace/dataspace.ex:410-424). That means even if patterns contain `$` captures, observers never learn the bound values. In syndicate-rs the observed assertion carries its match environment, so consumers can read captures; parity requires threading the bindings through to observers.","status":"closed","priority":2,"tags":["bug"],"created_at":1766190217492,"updated_at":1766190217499}
{"type":"issue","id":"absynthe-0p3rzl7e","rev":"01KCWJ7Y926KK71D0YPY8XNQDX","title":"Add client-side relay connection helper","body":"From Codex review of absynthe-z50: Need client-side relay for bidirectional communication. syndicate-rs has relay::connect_stream. Implementation: Add Relay.connect_client/2 with membrane tracking, bidirectional packet flow, and proxy ref to remote dataspace.","status":"open","priority":3,"tags":["feature"],"created_at":1766190217506,"updated_at":1766190217506}
{"type":"issue","id":"absynthe-5prwch7w","rev":"01KCWJ7Y98JQZM7J2SMRZV55SA","title":"Port pubsub producer/consumer from syndicate-rs","body":"What the examples demonstrate:\n- `producer` connects to a dataspace via relay and floods `<Says who payload>` messages (with configurable padding) in a tight loop.\n- `consumer` subscribes to `<Says $ $>` and counts messages per second using periodic timers.\n\nKey syndicate concepts:\n- Dataspace pub/sub with Observe patterns, remote dataspace connection via sturdyrefs, message templating, and timed reporting.\n\nWhy it is valuable to port:\n- Serves as a simple but meaningful pub/sub smoke test and throughput benchmark for Absynthe dataspace messaging and relay plumbing.\n\nReference paths in syndicate-rs:\n- /tmp/syndicate-rs-repo/syndicate-server/examples/producer.rs\n- /tmp/syndicate-rs-repo/syndicate-server/examples/consumer.rs","status":"open","priority":3,"tags":["feature"],"created_at":1766190217512,"updated_at":1766190217512}
{"type":"issue","id":"absynthe-9m3iybcz","rev":"01KCWJ7Y9FE1QM0KTZBYDVNC4M","title":"Port presence state producer/consumer from syndicate-rs","body":"What the examples demonstrate:\n- `state-producer` repeatedly asserts and retracts `<Present pid>` to model process presence/liveness.\n- `state-consumer` observes the same pattern and tracks arrivals, departures, occupancy, and event counts with per-second reporting.\n\nKey syndicate concepts:\n- Dataspace presence assertions with handles and explicit retraction, Observe pattern callbacks, on-assert/on-retract lifecycle handling, timers, and actor/facet coordination.\n\nWhy it is valuable to port:\n- Models distributed membership tracking—a common real-world use case—and exercises assertion lifecycle semantics Absynthe should mirror for presence monitoring and resource management.\n\nReference paths in syndicate-rs:\n- /tmp/syndicate-rs-repo/syndicate-server/examples/state-producer.rs\n- /tmp/syndicate-rs-repo/syndicate-server/examples/state-consumer.rs","status":"open","priority":3,"tags":["feature"],"created_at":1766190217519,"updated_at":1766190217519}
{"type":"issue","id":"absynthe-auutrb1r","rev":"01KCWJ7Y9PJC9BA86P8274SYZT","title":"Port PingPong latency example from syndicate-rs","body":"What the example demonstrates:\n- Ping or Pong role connected to a remote dataspace via `relay::connect_stream`, exchanging timestamped records and padding, measuring RTT and throughput with configurable turn/action counts.\n- Uses Observe on `<Pong ts padding>` / `<Ping ts padding>` patterns, periodic timers for reporting, and linked tasks to drive bursts of messages.\n\nKey syndicate concepts:\n- Remote dataspace access through sturdyrefs, Observe pattern subscription, dataspace request/response via message echo, linked tasks and periodic activation, and relay-based coordination.\n\nWhy it is valuable to port:\n- Provides an end-to-end distributed latency/throughput benchmark for Absynthe, validating dataspace pattern matching, relay integration, and request/response semantics between actors.\n\nReference paths in syndicate-rs:\n- /tmp/syndicate-rs-repo/syndicate-server/examples/pingpong.rs","status":"open","priority":3,"tags":["feature"],"created_at":1766190217526,"updated_at":1766190217526}
{"type":"issue","id":"absynthe-auutrb1r","rev":"01KCWJ7Y9WGTR4SV3MTA41DCH0","title":"Port PingPong latency example from syndicate-rs","body":"What the example demonstrates:\n- Ping or Pong role connected to a remote dataspace via `relay::connect_stream`, exchanging timestamped records and padding, measuring RTT and throughput with configurable turn/action counts.\n- Uses Observe on `<Pong ts padding>` / `<Ping ts padding>` patterns, periodic timers for reporting, and linked tasks to drive bursts of messages.\n\nKey syndicate concepts:\n- Remote dataspace access through sturdyrefs, Observe pattern subscription, dataspace request/response via message echo, linked tasks and periodic activation, and relay-based coordination.\n\nWhy it is valuable to port:\n- Provides an end-to-end distributed latency/throughput benchmark for Absynthe, validating dataspace pattern matching, relay integration, and request/response semantics between actors.\n\nReference paths in syndicate-rs:\n- /tmp/syndicate-rs-repo/syndicate-server/examples/pingpong.rs","status":"closed","priority":3,"tags":["feature"],"created_at":1766190217526,"updated_at":1766190217532}
{"type":"issue","id":"absynthe-3a81kw2z","rev":"01KCWJ7YA3MYN2ZD55F9YFVVD1","title":"Port Box and Client from syndicate-rs","body":"What the example demonstrates:\n- Box actor maintains a shared value in a dataspace, asserting `<box-state value>` via dataflow and applying `<set-box v>` messages; client observes state and drives an incrementing loop until stop.\n\nKey syndicate concepts:\n- Dataspace assertions/templates, Observe pattern subscribers, dataflow-driven updates, two cooperating actors sharing one dataspace, and stop conditions.\n\nWhy it is valuable to port:\n- Serves as a stateful service pattern for Absynthe: request/response over dataspace with persistent state, client-driven updates, and retraction-aware shutdown, useful for docs and tests.\n\nReference paths in syndicate-rs:\n- /tmp/syndicate-rs-repo/syndicate-macros/examples/box-and-client.rs","status":"open","priority":3,"tags":["feature"],"created_at":1766190217539,"updated_at":1766190217539}
{"type":"issue","id":"absynthe-3a81kw2z","rev":"01KCWJ7YA9HVPXT20Q7EXTHHKC","title":"Port Box and Client from syndicate-rs","body":"What the example demonstrates:\n- Box actor maintains a shared value in a dataspace, asserting `<box-state value>` via dataflow and applying `<set-box v>` messages; client observes state and drives an incrementing loop until stop.\n\nKey syndicate concepts:\n- Dataspace assertions/templates, Observe pattern subscribers, dataflow-driven updates, two cooperating actors sharing one dataspace, and stop conditions.\n\nWhy it is valuable to port:\n- Serves as a stateful service pattern for Absynthe: request/response over dataspace with persistent state, client-driven updates, and retraction-aware shutdown, useful for docs and tests.\n\nReference paths in syndicate-rs:\n- /tmp/syndicate-rs-repo/syndicate-macros/examples/box-and-client.rs","status":"closed","priority":3,"tags":["feature"],"created_at":1766190217539,"updated_at":1766190217545}
{"type":"issue","id":"absynthe-68a67ax3","rev":"01KCWJ7YAGFX9112K791WRBT0R","title":"Actor start docs don’t mention the flow_control option","body":"Absynthe.start_actor/1 (lib/absynthe.ex:70-95) and Absynthe.Core.Actor.start_link/1 (lib/absynthe/core/actor.ex:253-276) list only id/name/root_facet_id options, but init/1 builds per-actor flow control accounts when a :flow_control key is present (lib/absynthe/core/actor.ex:681-699) and exposes flow_control_stats. Without docs, users can’t discover how to enable/disable or tune backpressure (e.g., flow_control: true vs keyword options). Update the public API docs (and ideally README) to surface the option and defaults.","status":"open","priority":3,"tags":["bug"],"created_at":1766190217552,"updated_at":1766190217552}
{"type":"issue","id":"absynthe-68a67ax3","rev":"01KCWJ7YARQWGZPS4C6AN31DQH","title":"Actor start docs don’t mention the flow_control option","body":"Absynthe.start_actor/1 (lib/absynthe.ex:70-95) and Absynthe.Core.Actor.start_link/1 (lib/absynthe/core/actor.ex:253-276) list only id/name/root_facet_id options, but init/1 builds per-actor flow control accounts when a :flow_control key is present (lib/absynthe/core/actor.ex:681-699) and exposes flow_control_stats. Without docs, users can’t discover how to enable/disable or tune backpressure (e.g., flow_control: true vs keyword options). Update the public API docs (and ideally README) to surface the option and defaults.","status":"closed","priority":3,"tags":["bug"],"created_at":1766190217552,"updated_at":1766190217560}
{"type":"issue","id":"absynthe-4u1vt4tb","rev":"01KCWJ7YB0MA8603JZ2JQGEH0S","title":"Actor: deduplicate assertion payloads using handle->ref map","body":"## Problem\n`outbound_assertions` and `inbound_assertions` store full assertion values per handle (`lib/absynthe/core/actor.ex:45`), so large assertions are duplicated for tracking and retraction.\n\n## syndicate-rs approach\n- Dataspace stores full assertion once per handle in `handle_map` (`dataspace.rs:21-28,58-88`)\n- Skeleton caches use `AnyValue` which is Arc-backed (reference-counted)\n- Retractions use the stored value rather than duplicating\n\n## Implementation\n1. Store handle -> {ref, assertion_hash} in tracking maps instead of full values\n2. Fetch full assertion from Bag/Skeleton when needed for retraction\n3. Use content-addressed storage or interning for assertion values\n4. Consider Arc-wrapping Preserves values for cheap cloning\n\n## Expected impact\n- Reduces memory usage for actors with many large assertions\n- Lower priority than indexing/delivery changes","status":"open","priority":3,"tags":["feature"],"created_at":1766190217568,"updated_at":1766190217568}
{"type":"issue","id":"absynthe-3rxz6atx","rev":"01KCWJ7YB7EHF2KTXX2ZAW81A2","title":"Add interaction tracing support (Syndicate trace schema)","body":"The Synit/SAM docs include a tracing facility (see https://synit.org/book/guide/tracing.html and the syndicate trace schema) to capture turn events for debugging/analysis. Absynthe has no equivalent: we don’t emit trace packets or persist per-turn interaction logs. Add a tracing layer that hooks into Actor/Dataspace/Relay events, records turn events (assert/retract/message/sync, ref/handle info) in a structured format compatible with the Syndicate trace schema, and exposes a way to collect/ship traces (file/log or dataspace assertions). Include toggles to avoid perf hit when disabled and tests to ensure trace output matches protocol expectations.","status":"open","priority":3,"tags":["feature"],"created_at":1766190217575,"updated_at":1766190217575}
{"type":"issue","id":"absynthe-3bgi6pt9","rev":"01KCWJ7YBEXQEG86N2J19BNN8M","title":"Milestone 4: Observability and cross-node examples","body":"Add observability and examples for the broker/relay per docs/broker_relay_design.md. Scope:\n- Telemetry/logging for relay lifecycle, bytes in/out, assertion counts, and debt (hook into flow-control metrics once available).\n- Debt reporter service and log dataspace assertions similar to syndicate-server.\n- Runnable examples: cross-node ping/pong and presence over the relay; include instructions in README/docs.\n- Integration tests for handle/cap round-tripping and attenuation enforcement across the relay.","status":"open","priority":3,"tags":["task"],"created_at":1766190217582,"updated_at":1766190217582}
{"type":"issue","id":"absynthe-6k7zlsyc","rev":"01KCWJ7YBNPG17ZFCDVERFH5J7","title":"README overpromises Preserves support","body":"README claims “full support for the Preserves data format” (README.md:11), but dataspace pattern handling lacks set support (lib/absynthe/dataspace/pattern.ex:222-254 omits {:set,...} in extract_path) and drops capture environments in notifications (lib/absynthe/dataspace/dataspace.ex:410-424). Until those gaps are closed, the README should spell out the limitations instead of promising full coverage, to align expectations with current behavior and syndicate-rs parity.","status":"open","priority":3,"tags":["bug"],"created_at":1766190217589,"updated_at":1766190217589}
{"type":"issue","id":"absynthe-6jn97it2","rev":"01KCWJ7YBXWRY7FN8FXJ856FQX","title":"Observer docs promise match tracking that isn’t implemented","body":"Module docs for Absynthe.Dataspace.Observer describe active match tracking (active_handles, add_match/remove_match/match_count) and capture delivery (lib/absynthe/dataspace/observer.ex:1-170), but the dataspace never calls those functions—observe assertions are stored in Skeleton only and Observer structs’ active_handles stay empty (lib/absynthe/dataspace/dataspace.ex:320-360). Users reading the docs will expect match state and capture delivery that doesn’t exist. Either adjust the docs to describe the actual behavior or wire the match tracking up; syndicate-rs delivers captures and maintains subscription state.","status":"open","priority":3,"tags":["bug"],"created_at":1766190217597,"updated_at":1766190217597}
{"type":"issue","id":"absynthe-6jn97it2","rev":"01KCWJ7YC3GH91EQ7F834CDZSJ","title":"Observer docs promise match tracking that isn’t implemented","body":"Module docs for Absynthe.Dataspace.Observer describe active match tracking (active_handles, add_match/remove_match/match_count) and capture delivery (lib/absynthe/dataspace/observer.ex:1-170), but the dataspace never calls those functions—observe assertions are stored in Skeleton only and Observer structs’ active_handles stay empty (lib/absynthe/dataspace/dataspace.ex:320-360). Users reading the docs will expect match state and capture delivery that doesn’t exist. Either adjust the docs to describe the actual behavior or wire the match tracking up; syndicate-rs delivers captures and maintains subscription state.","status":"closed","priority":3,"tags":["bug"],"created_at":1766190217597,"updated_at":1766190217603}
{"type":"issue","id":"absynthe-5y7cu8fx","rev":"01KCWJ7YCA3WNPKTDEQC0A89NG","title":"pingpong_latency: fix Consumer event shape","body":"From Codex review: Consumer expects captures but gets full records. Fix on_publish/4 handling for Observe notifications.","status":"open","priority":4,"tags":["bug"],"created_at":1766190217610,"updated_at":1766190217610}
{"type":"issue","id":"absynthe-855lgysg","rev":"01KCWJ7YCGKRAHT3CPR1HV2YYF","title":"No advertisement protocol for presence discovery","body":"Section 8.5.6 introduces the built-in advertisement protocol to signal potential future assertions/publishers and decouple conversation setup from data flow. Our runtime has no advertisement records or support; observers can only see actual assertions or Observe subscriptions. Without advertise/claim, peers cannot discover that a capability or service might come online soon, which is part of the idiomatic Syndicate patterns. Add an advertisement protocol entity/helpers so actors can assert advertise(claim) records and peers can react to their presence/absence.","status":"open","priority":4,"tags":["task"],"created_at":1766190217616,"updated_at":1766190217616}
{"type":"dep","src_id":"absynthe-3mv0fa9z","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"active","created_at":1766190248647,"rev":"01KCWJ8WP7YYW3K9F1997FCT0S"}
{"type":"dep","src_id":"absynthe-bdj1bxrb","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"active","created_at":1766190248698,"rev":"01KCWJ8WQTGSGFYB13H7FAZ9CN"}
{"type":"dep","src_id":"absynthe-7nlpoxj0","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"active","created_at":1766190248749,"rev":"01KCWJ8WSD2J3ZRA3GE2Y39XBN"}
{"type":"dep","src_id":"absynthe-30a7tqhd","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"active","created_at":1766190248799,"rev":"01KCWJ8WTZWYX7X4NNKES4PV09"}
{"type":"dep","src_id":"absynthe-d2bk6ix9","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"active","created_at":1766190248850,"rev":"01KCWJ8WWJJ8VFXZSV8ZRB498Z"}
{"type":"dep","src_id":"absynthe-33se7el0","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"active","created_at":1766190248901,"rev":"01KCWJ8WY5B7Z062QNRGYTQ352"}
{"type":"dep","src_id":"absynthe-4u1vt4tb","dst_id":"absynthe-7fhh30hr","kind":"blocks","state":"active","created_at":1766190249393,"rev":"01KCWJ8XDHEPGW2DF9RYPYWYGG"}
{"type":"dep","src_id":"absynthe-3bgi6pt9","dst_id":"absynthe-3y3ikipm","kind":"parent","state":"active","created_at":1766190249487,"rev":"01KCWJ8XGFKPBF9VMNNCDJDT0W"}
{"type":"dep","src_id":"absynthe-5y7cu8fx","dst_id":"absynthe-0p3rzl7e","kind":"blocks","state":"active","created_at":1766190249630,"rev":"01KCWJ8XMYQPKTV2WVSCGDV1X0"}
{"type":"dep","src_id":"absynthe-3mv0fa9z","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"removed","created_at":1766190300762,"rev":"01KCWJAFJTYAKGWVFCMHWM4KMZ"}
{"type":"dep","src_id":"absynthe-bdj1bxrb","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"removed","created_at":1766190300818,"rev":"01KCWJAFMJW4B1C1FGENAZPXKR"}
{"type":"dep","src_id":"absynthe-7nlpoxj0","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"removed","created_at":1766190300879,"rev":"01KCWJAFPFABKHW5HV23T4F0CZ"}
{"type":"dep","src_id":"absynthe-30a7tqhd","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"removed","created_at":1766190300946,"rev":"01KCWJAFRJQHHDPDQTZWR4WQ29"}
{"type":"dep","src_id":"absynthe-d2bk6ix9","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"removed","created_at":1766190301003,"rev":"01KCWJAFTBCJZT0KZQR9SXAAYB"}
{"type":"dep","src_id":"absynthe-33se7el0","dst_id":"absynthe-aih56cx6","kind":"blocks","state":"removed","created_at":1766190301057,"rev":"01KCWJAFW1Z2BQ4CWT4APE6QRE"}
{"type":"dep","src_id":"absynthe-4u1vt4tb","dst_id":"absynthe-7fhh30hr","kind":"blocks","state":"removed","created_at":1766190301628,"rev":"01KCWJAGDWKR14VAF18G88D4CK"}
{"type":"dep","src_id":"absynthe-3bgi6pt9","dst_id":"absynthe-3y3ikipm","kind":"parent","state":"removed","created_at":1766190301747,"rev":"01KCWJAGHKSNMA79CX5Z2AH87Z"}
{"type":"dep","src_id":"absynthe-5y7cu8fx","dst_id":"absynthe-0p3rzl7e","kind":"blocks","state":"removed","created_at":1766190301893,"rev":"01KCWJAGP5A4YHP68VWWTBFE51"}
{"type":"dep","src_id":"absynthe-aih56cx6","dst_id":"absynthe-3mv0fa9z","kind":"blocks","state":"active","created_at":1766190302088,"rev":"01KCWJAGW8HNZ4F5GB464PV7B0"}
{"type":"dep","src_id":"absynthe-aih56cx6","dst_id":"absynthe-bdj1bxrb","kind":"blocks","state":"active","created_at":1766190302142,"rev":"01KCWJAGXY05KMH9N8YW7E3TZB"}
{"type":"dep","src_id":"absynthe-aih56cx6","dst_id":"absynthe-7nlpoxj0","kind":"blocks","state":"active","created_at":1766190302195,"rev":"01KCWJAGZKJX8FH1K0YNWQGYRH"}
{"type":"dep","src_id":"absynthe-aih56cx6","dst_id":"absynthe-30a7tqhd","kind":"blocks","state":"active","created_at":1766190302248,"rev":"01KCWJAH18E03P61FS0WBTJE9Y"}
{"type":"dep","src_id":"absynthe-aih56cx6","dst_id":"absynthe-d2bk6ix9","kind":"blocks","state":"active","created_at":1766190302302,"rev":"01KCWJAH2YEEVAX8D52PA631T0"}
{"type":"dep","src_id":"absynthe-aih56cx6","dst_id":"absynthe-33se7el0","kind":"blocks","state":"active","created_at":1766190302356,"rev":"01KCWJAH4M68MTPFWZ8S3RKYAH"}
{"type":"dep","src_id":"absynthe-7fhh30hr","dst_id":"absynthe-4u1vt4tb","kind":"blocks","state":"active","created_at":1766190302864,"rev":"01KCWJAHMGG7S4BE5GB1TXPCE0"}
{"type":"dep","src_id":"absynthe-3y3ikipm","dst_id":"absynthe-3bgi6pt9","kind":"parent","state":"active","created_at":1766190302963,"rev":"01KCWJAHQKAY4854EVKNDYNQFW"}
{"type":"dep","src_id":"absynthe-0p3rzl7e","dst_id":"absynthe-5y7cu8fx","kind":"blocks","state":"active","created_at":1766190303105,"rev":"01KCWJAHW1YHQPX7FJKBRJ5WPX"}
